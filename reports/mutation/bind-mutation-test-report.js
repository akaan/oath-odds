document.querySelector('mutation-test-report-app').report = {"files":{"/home/runner/work/oath-odds/oath-odds/src/Fraction.ts":{"language":"typescript","mutants":[{"id":"0","location":{"end":{"column":4,"line":21},"start":{"column":55,"line":17}},"mutatorName":"BlockStatement","replacement":"{}","status":"Killed","description":"Killed by: Fraction fractions with same numerator and denominator are equal"},{"id":"2","location":{"end":{"column":45,"line":34},"start":{"column":7,"line":33}},"mutatorName":"ArithmeticOperator","replacement":"this._numerator * other._denominator - other._numerator * this._denominator","status":"Killed","description":"Killed by: Fraction can add fractions"},{"id":"3","location":{"end":{"column":43,"line":33},"start":{"column":7,"line":33}},"mutatorName":"ArithmeticOperator","replacement":"this._numerator / other._denominator","status":"Killed","description":"Killed by: Fraction can add fractions"},{"id":"4","location":{"end":{"column":45,"line":34},"start":{"column":9,"line":34}},"mutatorName":"ArithmeticOperator","replacement":"other._numerator / this._denominator","status":"Killed","description":"Killed by: Fraction can add fractions"},{"id":"5","location":{"end":{"column":45,"line":35},"start":{"column":7,"line":35}},"mutatorName":"ArithmeticOperator","replacement":"this._denominator / other._denominator","status":"Killed","description":"Killed by: Fraction can add fractions"},{"id":"6","location":{"end":{"column":4,"line":52},"start":{"column":46,"line":47}},"mutatorName":"BlockStatement","replacement":"{}","status":"Killed","description":"Killed by: Fraction can multiply fractions"},{"id":"7","location":{"end":{"column":41,"line":49},"start":{"column":7,"line":49}},"mutatorName":"ArithmeticOperator","replacement":"this._numerator / other._numerator","status":"Survived"},{"id":"8","location":{"end":{"column":45,"line":50},"start":{"column":7,"line":50}},"mutatorName":"ArithmeticOperator","replacement":"this._denominator / other._denominator","status":"Killed","description":"Killed by: Fraction can multiply fractions"},{"id":"9","location":{"end":{"column":4,"line":62},"start":{"column":28,"line":60}},"mutatorName":"BlockStatement","replacement":"{}","status":"Killed","description":"Killed by: Fraction can compute to float"},{"id":"10","location":{"end":{"column":47,"line":61},"start":{"column":12,"line":61}},"mutatorName":"ArithmeticOperator","replacement":"this._numerator * this._denominator","status":"Killed","description":"Killed by: Fraction can compute to float"},{"id":"11","location":{"end":{"column":4,"line":79},"start":{"column":43,"line":72}},"mutatorName":"BlockStatement","replacement":"{}","status":"Killed","description":"Killed by: Fraction fractions with same numerator and denominator are equal"},{"id":"12","location":{"end":{"column":47,"line":77},"start":{"column":7,"line":76}},"mutatorName":"ConditionalExpression","replacement":"true","status":"Killed","description":"Killed by: Fraction fractions with same numerator and different denominator are not equal"},{"id":"13","location":{"end":{"column":47,"line":77},"start":{"column":7,"line":76}},"mutatorName":"ConditionalExpression","replacement":"false","status":"Killed","description":"Killed by: Fraction fractions with same numerator and denominator are equal"},{"id":"14","location":{"end":{"column":47,"line":77},"start":{"column":7,"line":76}},"mutatorName":"LogicalOperator","replacement":"this._numerator === other._numerator || this._denominator === other._denominator","status":"Killed","description":"Killed by: Fraction fractions with same numerator and different denominator are not equal"},{"id":"15","location":{"end":{"column":43,"line":76},"start":{"column":7,"line":76}},"mutatorName":"ConditionalExpression","replacement":"true","status":"Survived"},{"id":"16","location":{"end":{"column":43,"line":76},"start":{"column":7,"line":76}},"mutatorName":"ConditionalExpression","replacement":"false","status":"Killed","description":"Killed by: Fraction fractions with same numerator and denominator are equal"},{"id":"17","location":{"end":{"column":43,"line":76},"start":{"column":7,"line":76}},"mutatorName":"EqualityOperator","replacement":"this._numerator !== other._numerator","status":"Killed","description":"Killed by: Fraction fractions with same numerator and denominator are equal"},{"id":"18","location":{"end":{"column":47,"line":77},"start":{"column":7,"line":77}},"mutatorName":"ConditionalExpression","replacement":"true","status":"Killed","description":"Killed by: Fraction fractions with same numerator and different denominator are not equal"},{"id":"19","location":{"end":{"column":47,"line":77},"start":{"column":7,"line":77}},"mutatorName":"ConditionalExpression","replacement":"false","status":"Killed","description":"Killed by: Fraction fractions with same numerator and denominator are equal"},{"id":"20","location":{"end":{"column":47,"line":77},"start":{"column":7,"line":77}},"mutatorName":"EqualityOperator","replacement":"this._denominator !== other._denominator","status":"Killed","description":"Killed by: Fraction fractions with same numerator and denominator are equal"},{"id":"21","location":{"end":{"column":4,"line":91},"start":{"column":27,"line":85}},"mutatorName":"BlockStatement","replacement":"{}","status":"Killed","description":"Killed by: Fraction fractions reducing to the same fraction are equal"},{"id":"22","location":{"end":{"column":12,"line":87},"start":{"column":9,"line":87}},"mutatorName":"ConditionalExpression","replacement":"true","status":"Survived"},{"id":"23","location":{"end":{"column":12,"line":87},"start":{"column":9,"line":87}},"mutatorName":"ConditionalExpression","replacement":"false","status":"Killed","description":"Killed by: Fraction fractions reducing to the same fraction are equal"},{"id":"24","location":{"end":{"column":6,"line":90},"start":{"column":14,"line":87}},"mutatorName":"BlockStatement","replacement":"{}","status":"Killed","description":"Killed by: Fraction fractions reducing to the same fraction are equal"},{"id":"25","location":{"end":{"column":46,"line":88},"start":{"column":25,"line":88}},"mutatorName":"ArithmeticOperator","replacement":"this._numerator * div","status":"Killed","description":"Killed by: Fraction fractions reducing to the same fraction are equal"},{"id":"26","location":{"end":{"column":50,"line":89},"start":{"column":27,"line":89}},"mutatorName":"ArithmeticOperator","replacement":"this._denominator * div","status":"Killed","description":"Killed by: Fraction fractions reducing to the same fraction are equal"},{"id":"27","location":{"end":{"column":2,"line":114},"start":{"column":44,"line":104}},"mutatorName":"BlockStatement","replacement":"{}","status":"Killed","description":"Killed by: Fraction fractions reducing to the same fraction are equal"},{"id":"28","location":{"end":{"column":12,"line":105},"start":{"column":7,"line":105}},"mutatorName":"ConditionalExpression","replacement":"true","status":"Killed","description":"Killed by: Fraction fractions with same numerator and denominator are equal"},{"id":"29","location":{"end":{"column":12,"line":105},"start":{"column":7,"line":105}},"mutatorName":"ConditionalExpression","replacement":"false","status":"Survived"},{"id":"30","location":{"end":{"column":12,"line":105},"start":{"column":7,"line":105}},"mutatorName":"EqualityOperator","replacement":"b >= a","status":"Survived"},{"id":"31","location":{"end":{"column":12,"line":105},"start":{"column":7,"line":105}},"mutatorName":"EqualityOperator","replacement":"b <= a","status":"Killed","description":"Killed by: Fraction fractions with same numerator and denominator are equal"},{"id":"32","location":{"end":{"column":4,"line":107},"start":{"column":14,"line":105}},"mutatorName":"BlockStatement","replacement":"{}","status":"Survived"},{"id":"1","location":{"end":{"column":4,"line":37},"start":{"column":41,"line":31}},"mutatorName":"BlockStatement","replacement":"{}","status":"Killed","description":"Killed by: Fraction can add fractions"},{"id":"33","location":{"end":{"column":14,"line":109},"start":{"column":7,"line":109}},"mutatorName":"ConditionalExpression","replacement":"true","status":"Killed","description":"Killed by: Fraction can add fractions"},{"id":"35","location":{"end":{"column":14,"line":109},"start":{"column":7,"line":109}},"mutatorName":"EqualityOperator","replacement":"b !== 0","status":"Killed","description":"Killed by: Fraction can add fractions"},{"id":"36","location":{"end":{"column":4,"line":111},"start":{"column":16,"line":109}},"mutatorName":"BlockStatement","replacement":"{}","status":"Killed","description":"Killed by: Fraction fractions reducing to the same fraction are equal"},{"id":"34","location":{"end":{"column":14,"line":109},"start":{"column":7,"line":109}},"mutatorName":"ConditionalExpression","replacement":"false","status":"Killed","description":"Killed by: Fraction fractions with same numerator and denominator are equal"},{"id":"37","location":{"end":{"column":4,"line":113},"start":{"column":10,"line":111}},"mutatorName":"BlockStatement","replacement":"{}","status":"Killed","description":"Killed by: Fraction fractions reducing to the same fraction are equal"},{"id":"38","location":{"end":{"column":24,"line":112},"start":{"column":19,"line":112}},"mutatorName":"ArithmeticOperator","replacement":"a * b","status":"Killed","description":"Killed by: Fraction fractions with same numerator and denominator are equal"}],"source":"/**\n * A fraction with a numerator and a denominator.\n */\nexport class Fraction {\n  private _numerator: number;\n  private _denominator: number;\n\n  /**\n   * Creates and immediately reduce the fraction using the greatest common\n   * divider of the numerator and denominator.\n   *\n   * @param {number} numerator\n   *   The numerator of this fraction.\n   * @param {number} denominator\n   *   The denominator of this fraction.\n   */\n  constructor(numerator: number, denominator: number) {\n    this._numerator = numerator;\n    this._denominator = denominator;\n    this._reduce();\n  }\n\n  /**\n   * Return a new fraction by adding the given fraction to this fraction.\n   *\n   * @param {Fraction} other\n   *   The fraction to add to this one.\n   * @return {Fraction}\n   *   A new fraction obtained by adding the 2 fractions.\n   */\n  public add(other: Fraction): Fraction {\n    return new Fraction(\n      this._numerator * other._denominator +\n        other._numerator * this._denominator,\n      this._denominator * other._denominator\n    );\n  }\n\n  /**\n   * Return a new fraction by multiplying the given fraction by this fraction.\n   *\n   * @param {Fraction} other\n   *   The fraction to multply by this one.\n   * @return {Fraction}\n   *   A new fraction obtained by multiplying the 2 fractions.\n   */\n  public multiply(other: Fraction): Fraction {\n    return new Fraction(\n      this._numerator * other._numerator,\n      this._denominator * other._denominator\n    );\n  }\n\n  /**\n   * Returns the number value of this fraction.\n   *\n   * @return {number}\n   *   The number value of this fraction\n   */\n  public valueOf(): number {\n    return this._numerator / this._denominator;\n  }\n\n  /**\n   * Checks if this fraction is equal to the provided fraction.\n   *\n   * @param {Fraction} other\n   *   The fraction to compare to.\n   * @return {boolean}\n   *   `true` if the 2 fractions are equal, `false` else.\n   */\n  public sameAs(other: Fraction): boolean {\n    this._reduce();\n    other._reduce();\n    return (\n      this._numerator === other._numerator &&\n      this._denominator === other._denominator\n    );\n  }\n\n  /**\n   * Reduce the fraction using the greatest common divider of the numerator\n   * and the denominator.\n   */\n  private _reduce(): void {\n    const div = gcd(this._numerator, this._denominator);\n    if (div) {\n      this._numerator = this._numerator / div;\n      this._denominator = this._denominator / div;\n    }\n  }\n}\n\n/**\n * Computes the greatest common divider of 2 integers.\n *\n * @param {number} a\n *   First integer.\n * @param {number} b\n *   Second integer.\n * @returns {number}\n *   Greatest common divider of `a` and `b`.\n */\nfunction gcd(a: number, b: number): number {\n  if (b > a) {\n    return gcd(b, a);\n  }\n\n  if (b === 0) {\n    return a;\n  } else {\n    return gcd(b, a % b);\n  }\n}\n"},"/home/runner/work/oath-odds/oath-odds/src/RandomDevice.ts":{"language":"typescript","mutants":[{"id":"39","location":{"end":{"column":57,"line":24},"start":{"column":55,"line":24}},"mutatorName":"ArrayDeclaration","replacement":"[\"Stryker was here\"]","status":"Killed","description":"Killed by: odds with only 1 random device"},{"id":"40","location":{"end":{"column":4,"line":39},"start":{"column":69,"line":32}},"mutatorName":"BlockStatement","replacement":"{}","status":"Killed","description":"Killed by: odds with only 1 random device"},{"id":"41","location":{"end":{"column":6,"line":38},"start":{"column":42,"line":33}},"mutatorName":"BlockStatement","replacement":"{}","status":"Killed","description":"Killed by: odds with only 1 random device"},{"id":"43","location":{"end":{"column":23,"line":36},"start":{"column":14,"line":36}},"mutatorName":"ArrayDeclaration","replacement":"[]","status":"Killed","description":"Killed by: odds with only 1 random device"},{"id":"42","location":{"end":{"column":8,"line":37},"start":{"column":35,"line":34}},"mutatorName":"ObjectLiteral","replacement":"{}","status":"Killed","description":"Killed by: odds with only 1 random device"},{"id":"44","location":{"end":{"column":4,"line":50},"start":{"column":56,"line":48}},"mutatorName":"BlockStatement","replacement":"{}","status":"Killed","description":"Killed by: odds with only 1 random device"}],"source":"import { Fraction } from \"./Fraction\";\nimport { SetWithOdds } from \"./SetWithOdds\";\n\n/**\n * A device generating random outcomes with specific odds. For example, a\n * classic 6-sided can be created with the following code:\n *\n * ```javascript\n * const d6 = new RandomDevice<number>([\n *   [1, new Fraction(1, 6)],\n *   [2, new Fraction(1, 6)],\n *   [3, new Fraction(1, 6)],\n *   [4, new Fraction(1, 6)],\n *   [5, new Fraction(1, 6)],\n *   [6, new Fraction(1, 6)]\n * ]);\n * ```\n *\n * @param Outcome\n *   The type of the outcome generated from this random device.\n */\nexport class RandomDevice<Outcome> {\n  /** The sets and associated odds this random device generates. */\n  private _outcomesWithOdds: SetWithOdds<Outcome>[] = [];\n\n  /**\n   * Constructor for a random device.\n   *\n   * @param {ReadonlyArray<[Outcome, Fraction]>} outcomesWithOdds\n   *   An array of (outcome, odds) pairs.\n   */\n  constructor(outcomesWithOdds: ReadonlyArray<[Outcome, Fraction]>) {\n    for (const elem of outcomesWithOdds) {\n      this._outcomesWithOdds.push({\n        odds: elem[1],\n        set: [elem[0]],\n      });\n    }\n  }\n\n  /**\n   * Get the possible outcomes and odds for this random device.\n   *\n   * @returns {SetWithOdds<Outcome>[]}\n   *   The possible outcomes (as sets) this random device can generate along\n   * with the odds of each outcome.\n   */\n  public getOutcomesWithOdds(): SetWithOdds<Outcome>[] {\n    return this._outcomesWithOdds;\n  }\n}\n"},"/home/runner/work/oath-odds/oath-odds/src/SetWithOdds.ts":{"language":"typescript","mutants":[{"id":"45","location":{"end":{"column":2,"line":39},"start":{"column":23,"line":34}},"mutatorName":"BlockStatement","replacement":"{}","status":"Killed","description":"Killed by: odds with 2 random devices"},{"id":"46","location":{"end":{"column":4,"line":38},"start":{"column":10,"line":35}},"mutatorName":"ObjectLiteral","replacement":"{}","status":"Killed","description":"Killed by: odds with 2 random devices"},{"id":"47","location":{"end":{"column":39,"line":37},"start":{"column":10,"line":37}},"mutatorName":"ArrayDeclaration","replacement":"[]","status":"Killed","description":"Killed by: odds with 2 random devices"}],"source":"import { Fraction } from \"./Fraction\";\n\n/**\n * This type encapsulate a set and the odds of obtaining this set from a random\n * device.\n *\n * @param Outcome The type of element in the set.\n */\nexport interface SetWithOdds<Outcome> {\n  /** The set. */\n  set: Outcome[];\n  /** The odds of obtaining this set from a random device. */\n  odds: Fraction;\n}\n\n/**\n * Combine two sets with odds into a single one. Sets are merged and odds are\n * multiplied.\n *\n * @param O\n *   Type for the first set.\n * @param P\n *   Type for the second set.\n * @param {SetWithOdds<O>} first\n *   The first set to be combined.\n * @param {SetWithOdds<P>} second\n *   The second set to be combined.\n * @returns {SetWithOdds<O | P>}\n *   The result of combining the two sets.\n */\nexport function combineSetWithOdds<O, P>(\n  first: SetWithOdds<O>,\n  second: SetWithOdds<P>\n): SetWithOdds<O | P> {\n  return {\n    odds: first.odds.multiply(second.odds),\n    set: [...first.set, ...second.set],\n  };\n}\n"},"/home/runner/work/oath-odds/oath-odds/src/combinatorics.ts":{"language":"typescript","mutants":[{"id":"48","location":{"end":{"column":2,"line":30},"start":{"column":60,"line":17}},"mutatorName":"BlockStatement","replacement":"{}","status":"Killed","description":"Killed by: combinatorics cartesianProduct should compute cartesian product of 2 arrays"},{"id":"49","location":{"end":{"column":6,"line":27},"start":{"column":31,"line":19}},"mutatorName":"BlockStatement","replacement":"{}","status":"Killed","description":"Killed by: combinatorics cartesianProduct should compute cartesian product of 2 arrays"},{"id":"50","location":{"end":{"column":10,"line":25},"start":{"column":29,"line":21}},"mutatorName":"BlockStatement","replacement":"{}","status":"Killed","description":"Killed by: combinatorics cartesianProduct should compute cartesian product of 2 arrays"},{"id":"51","location":{"end":{"column":12,"line":24},"start":{"column":36,"line":22}},"mutatorName":"BlockStatement","replacement":"{}","status":"Killed","description":"Killed by: combinatorics cartesianProduct should compute cartesian product of 2 arrays"},{"id":"52","location":{"end":{"column":29,"line":23},"start":{"column":20,"line":23}},"mutatorName":"ArrayDeclaration","replacement":"[]","status":"Killed","description":"Killed by: combinatorics cartesianProduct should compute cartesian product of 2 arrays"}],"source":"import { flatten } from \"./utils\";\n\n/**\n * Computes the cartesian product of arrays of elements.\n *\n * ```javascript\n * cartesianProduct([1, 2], [3, 4]) // [[1, 3], [1, 4], [2, 3], [2, 4]]\n * ```\n *\n * @param T`\n *   Type of the elements in the arrays.\n * @param {T[][]} sets\n *   The sets to use for the cartesian product.\n * @returns {T[][]}\n *   The cartesian product of all provided sets.\n */\nexport function cartesianProduct<T>(...sets: T[][]): T[][] {\n  return sets.reduce(\n    (acc: T[][], set: T[]) => {\n      return flatten(\n        acc.map((x: T[]) => {\n          return set.map((y: T) => {\n            return [...x, y];\n          });\n        })\n      );\n    },\n    [[]] as T[][]\n  );\n}\n"},"/home/runner/work/oath-odds/oath-odds/src/index.ts":{"language":"typescript","mutants":[{"id":"53","location":{"end":{"column":2,"line":50},"start":{"column":72,"line":16}},"mutatorName":"BlockStatement","replacement":"{}","status":"Killed","description":"Killed by: odds with only 1 random device"},{"id":"54","location":{"end":{"column":50,"line":18},"start":{"column":20,"line":18}},"mutatorName":"ArrowFunction","replacement":"() => undefined","status":"Killed","description":"Killed by: odds with only 1 random device"},{"id":"55","location":{"end":{"column":73,"line":21},"start":{"column":32,"line":21}},"mutatorName":"ArrowFunction","replacement":"() => undefined","status":"Killed","description":"Killed by: odds with only 1 random device"},{"id":"56","location":{"end":{"column":6,"line":45},"start":{"column":61,"line":24}},"mutatorName":"BlockStatement","replacement":"{}","status":"Killed","description":"Killed by: odds with only 1 random device"},{"id":"57","location":{"end":{"column":27,"line":25},"start":{"column":11,"line":25}},"mutatorName":"ConditionalExpression","replacement":"true","status":"Killed","description":"Killed by: odds with only 1 random device"},{"id":"59","location":{"end":{"column":27,"line":25},"start":{"column":11,"line":25}},"mutatorName":"EqualityOperator","replacement":"acc.length !== 0","status":"Killed","description":"Killed by: odds with only 1 random device"},{"id":"58","location":{"end":{"column":27,"line":25},"start":{"column":11,"line":25}},"mutatorName":"ConditionalExpression","replacement":"false","status":"Survived"},{"id":"60","location":{"end":{"column":8,"line":27},"start":{"column":29,"line":25}},"mutatorName":"BlockStatement","replacement":"{}","status":"Killed","description":"Killed by: odds with only 1 random device"},{"id":"61","location":{"end":{"column":25,"line":26},"start":{"column":16,"line":26}},"mutatorName":"ArrayDeclaration","replacement":"[]","status":"Killed","description":"Killed by: odds with only 1 random device"},{"id":"62","location":{"end":{"column":8,"line":44},"start":{"column":14,"line":27}},"mutatorName":"BlockStatement","replacement":"{}","status":"Killed","description":"Killed by: odds with only 1 random device"},{"id":"63","location":{"end":{"column":54,"line":30},"start":{"column":48,"line":29}},"mutatorName":"ArrowFunction","replacement":"() => undefined","status":"Killed","description":"Killed by: odds combines identical sets"},{"id":"64","location":{"end":{"column":34,"line":32},"start":{"column":13,"line":32}},"mutatorName":"ConditionalExpression","replacement":"true","status":"Killed","description":"Killed by: odds with only 1 random device"},{"id":"66","location":{"end":{"column":34,"line":32},"start":{"column":13,"line":32}},"mutatorName":"EqualityOperator","replacement":"matchingSetIndex >= -1","status":"Killed","description":"Killed by: odds with only 1 random device"},{"id":"67","location":{"end":{"column":34,"line":32},"start":{"column":13,"line":32}},"mutatorName":"EqualityOperator","replacement":"matchingSetIndex <= -1","status":"Killed","description":"Killed by: odds with only 1 random device"},{"id":"65","location":{"end":{"column":34,"line":32},"start":{"column":13,"line":32}},"mutatorName":"ConditionalExpression","replacement":"false","status":"Killed","description":"Killed by: odds combines identical sets"},{"id":"68","location":{"end":{"column":34,"line":32},"start":{"column":32,"line":32}},"mutatorName":"UnaryOperator","replacement":"+1","status":"Killed","description":"Killed by: odds combines identical sets"},{"id":"69","location":{"end":{"column":10,"line":40},"start":{"column":36,"line":32}},"mutatorName":"BlockStatement","replacement":"{}","status":"Killed","description":"Killed by: odds combines identical sets"},{"id":"70","location":{"end":{"column":12,"line":37},"start":{"column":30,"line":34}},"mutatorName":"ObjectLiteral","replacement":"{}","status":"Killed","description":"Killed by: odds combines identical sets"},{"id":"72","location":{"end":{"column":35,"line":42},"start":{"column":18,"line":42}},"mutatorName":"ArrayDeclaration","replacement":"[]","status":"Killed","description":"Killed by: odds with only 1 random device"},{"id":"71","location":{"end":{"column":10,"line":43},"start":{"column":16,"line":40}},"mutatorName":"BlockStatement","replacement":"{}","status":"Killed","description":"Killed by: odds with only 1 random device"},{"id":"73","location":{"end":{"column":7,"line":46},"start":{"column":5,"line":46}},"mutatorName":"ArrayDeclaration","replacement":"[\"Stryker was here\"]","status":"Killed","description":"Killed by: odds with only 1 random device"}],"source":"import { cartesianProduct } from \"./combinatorics\";\nimport { RandomDevice } from \"./RandomDevice\";\nimport { combineSetWithOdds, SetWithOdds } from \"./SetWithOdds\";\nimport { arrayEquals, replace } from \"./utils\";\n\n/**\n * Computes all possible sets from the provided list of random devices along\n * with the odds of obtaining this particular set.\n *\n * @param {Array<RandomDevice<any>>} devices\n *   The list of random devices from which to generate possible sets.\n * @returns {Array<SetWithOdds<any>>}\n *   All possible sets that can be obtainded from this lsit of random devices\n *   along with the odds of obtaining this particular set.\n */\nexport function odds(devices: RandomDevice<any>[]): SetWithOdds<any>[] {\n  const product = cartesianProduct(\n    ...devices.map((d) => d.getOutcomesWithOdds())\n  );\n\n  const combined = product.map((sets) => sets.reduce(combineSetWithOdds));\n\n  const grouped = combined.reduce(\n    (acc: SetWithOdds<any>[], current: SetWithOdds<any>) => {\n      if (acc.length === 0) {\n        return [current];\n      } else {\n        // Find an equivalent set\n        const matchingSetIndex = acc.findIndex(({ set }) =>\n          arrayEquals(set.sort(), current.set.sort())\n        );\n        if (matchingSetIndex > -1) {\n          // Update the existing set by adding the odds\n          const updatedSet = {\n            odds: acc[matchingSetIndex].odds.add(current.odds),\n            set: acc[matchingSetIndex].set,\n          };\n\n          return replace(acc, matchingSetIndex, updatedSet);\n        } else {\n          // Add the set\n          return [...acc, current];\n        }\n      }\n    },\n    []\n  );\n\n  return grouped;\n}\n"},"/home/runner/work/oath-odds/oath-odds/src/utils.ts":{"language":"typescript","mutants":[{"id":"74","location":{"end":{"column":2,"line":13},"start":{"column":47,"line":11}},"mutatorName":"BlockStatement","replacement":"{}","status":"Killed","description":"Killed by: combinatorics cartesianProduct should compute cartesian product of 2 arrays"},{"id":"75","location":{"end":{"column":12,"line":12},"start":{"column":10,"line":12}},"mutatorName":"ArrayDeclaration","replacement":"[\"Stryker was here\"]","status":"Survived"},{"id":"76","location":{"end":{"column":28,"line":12},"start":{"column":26,"line":12}},"mutatorName":"ArrayDeclaration","replacement":"[\"Stryker was here\"]","status":"Killed","description":"Killed by: combinatorics cartesianProduct should compute cartesian product of 2 arrays"},{"id":"77","location":{"end":{"column":2,"line":43},"start":{"column":57,"line":27}},"mutatorName":"BlockStatement","replacement":"{}","status":"Killed","description":"Killed by: odds with only 1 random device"},{"id":"78","location":{"end":{"column":46,"line":28},"start":{"column":7,"line":28}},"mutatorName":"ConditionalExpression","replacement":"true","status":"Killed","description":"Killed by: odds with only 1 random device"},{"id":"79","location":{"end":{"column":46,"line":28},"start":{"column":7,"line":28}},"mutatorName":"ConditionalExpression","replacement":"false","status":"Survived"},{"id":"80","location":{"end":{"column":46,"line":28},"start":{"column":7,"line":28}},"mutatorName":"BooleanLiteral","replacement":"Array.isArray(a) && Array.isArray(b)","status":"Killed","description":"Killed by: odds with only 1 random device"},{"id":"81","location":{"end":{"column":45,"line":28},"start":{"column":9,"line":28}},"mutatorName":"ConditionalExpression","replacement":"true","status":"Survived"},{"id":"82","location":{"end":{"column":45,"line":28},"start":{"column":9,"line":28}},"mutatorName":"ConditionalExpression","replacement":"false","status":"Killed","description":"Killed by: odds with only 1 random device"},{"id":"84","location":{"end":{"column":4,"line":30},"start":{"column":48,"line":28}},"mutatorName":"BlockStatement","replacement":"{}","status":"Survived"},{"id":"83","location":{"end":{"column":45,"line":28},"start":{"column":9,"line":28}},"mutatorName":"LogicalOperator","replacement":"Array.isArray(a) || Array.isArray(b)","status":"Survived"},{"id":"86","location":{"end":{"column":28,"line":32},"start":{"column":7,"line":32}},"mutatorName":"ConditionalExpression","replacement":"true","status":"Killed","description":"Killed by: odds with only 1 random device"},{"id":"85","location":{"end":{"column":17,"line":29},"start":{"column":12,"line":29}},"mutatorName":"BooleanLiteral","replacement":"true","status":"Survived"},{"id":"87","location":{"end":{"column":28,"line":32},"start":{"column":7,"line":32}},"mutatorName":"ConditionalExpression","replacement":"false","status":"Survived"},{"id":"88","location":{"end":{"column":28,"line":32},"start":{"column":7,"line":32}},"mutatorName":"EqualityOperator","replacement":"a.length === b.length","status":"Killed","description":"Killed by: odds with only 1 random device"},{"id":"89","location":{"end":{"column":4,"line":34},"start":{"column":30,"line":32}},"mutatorName":"BlockStatement","replacement":"{}","status":"Survived"},{"id":"90","location":{"end":{"column":17,"line":33},"start":{"column":12,"line":33}},"mutatorName":"BooleanLiteral","replacement":"true","status":"Survived"},{"id":"91","location":{"end":{"column":31,"line":36},"start":{"column":19,"line":36}},"mutatorName":"ConditionalExpression","replacement":"false","status":"Killed","description":"Killed by: odds with only 1 random device"},{"id":"92","location":{"end":{"column":31,"line":36},"start":{"column":19,"line":36}},"mutatorName":"EqualityOperator","replacement":"i <= a.length","status":"Survived"},{"id":"93","location":{"end":{"column":31,"line":36},"start":{"column":19,"line":36}},"mutatorName":"EqualityOperator","replacement":"i >= a.length","status":"Killed","description":"Killed by: odds with only 1 random device"},{"id":"95","location":{"end":{"column":4,"line":40},"start":{"column":38,"line":36}},"mutatorName":"BlockStatement","replacement":"{}","status":"Killed","description":"Killed by: odds with only 1 random device"},{"id":"96","location":{"end":{"column":22,"line":37},"start":{"column":9,"line":37}},"mutatorName":"ConditionalExpression","replacement":"true","status":"Killed","description":"Killed by: odds with only 1 random device"},{"id":"97","location":{"end":{"column":22,"line":37},"start":{"column":9,"line":37}},"mutatorName":"ConditionalExpression","replacement":"false","status":"Killed","description":"Killed by: odds with only 1 random device"},{"id":"98","location":{"end":{"column":22,"line":37},"start":{"column":9,"line":37}},"mutatorName":"EqualityOperator","replacement":"a[i] === b[i]","status":"Killed","description":"Killed by: odds with only 1 random device"},{"id":"99","location":{"end":{"column":6,"line":39},"start":{"column":24,"line":37}},"mutatorName":"BlockStatement","replacement":"{}","status":"Killed","description":"Killed by: odds with only 1 random device"},{"id":"100","location":{"end":{"column":19,"line":38},"start":{"column":14,"line":38}},"mutatorName":"BooleanLiteral","replacement":"true","status":"Killed","description":"Killed by: odds with only 1 random device"},{"id":"101","location":{"end":{"column":14,"line":42},"start":{"column":10,"line":42}},"mutatorName":"BooleanLiteral","replacement":"false","status":"Killed","description":"Killed by: odds with only 1 random device"},{"id":"102","location":{"end":{"column":2,"line":65},"start":{"column":67,"line":59}},"mutatorName":"BlockStatement","replacement":"{}","status":"Killed","description":"Killed by: odds combines identical sets"},{"id":"103","location":{"end":{"column":37,"line":60},"start":{"column":7,"line":60}},"mutatorName":"ConditionalExpression","replacement":"true","status":"Killed","description":"Killed by: utils replace should return the same array if specified index is < 0"},{"id":"104","location":{"end":{"column":37,"line":60},"start":{"column":7,"line":60}},"mutatorName":"ConditionalExpression","replacement":"false","status":"Killed","description":"Killed by: odds combines identical sets"},{"id":"105","location":{"end":{"column":37,"line":60},"start":{"column":7,"line":60}},"mutatorName":"LogicalOperator","replacement":"idx >= 0 || idx < elems.length","status":"Killed","description":"Killed by: utils replace should return the same array if specified index is < 0"},{"id":"106","location":{"end":{"column":15,"line":60},"start":{"column":7,"line":60}},"mutatorName":"ConditionalExpression","replacement":"true","status":"Killed","description":"Killed by: utils replace should return the same array if specified index is < 0"},{"id":"107","location":{"end":{"column":15,"line":60},"start":{"column":7,"line":60}},"mutatorName":"ConditionalExpression","replacement":"false","status":"Killed","description":"Killed by: odds combines identical sets"},{"id":"108","location":{"end":{"column":15,"line":60},"start":{"column":7,"line":60}},"mutatorName":"EqualityOperator","replacement":"idx > 0","status":"Killed","description":"Killed by: utils replace should be able to replace at first position"},{"id":"109","location":{"end":{"column":15,"line":60},"start":{"column":7,"line":60}},"mutatorName":"EqualityOperator","replacement":"idx < 0","status":"Killed","description":"Killed by: odds combines identical sets"},{"id":"110","location":{"end":{"column":37,"line":60},"start":{"column":19,"line":60}},"mutatorName":"ConditionalExpression","replacement":"true","status":"Killed","description":"Killed by: utils replace should return the same array if specified index is > array length"},{"id":"111","location":{"end":{"column":37,"line":60},"start":{"column":19,"line":60}},"mutatorName":"ConditionalExpression","replacement":"false","status":"Killed","description":"Killed by: odds combines identical sets"},{"id":"112","location":{"end":{"column":37,"line":60},"start":{"column":19,"line":60}},"mutatorName":"EqualityOperator","replacement":"idx <= elems.length","status":"Killed","description":"Killed by: utils replace should return the same array if specified index is > array length"},{"id":"113","location":{"end":{"column":37,"line":60},"start":{"column":19,"line":60}},"mutatorName":"EqualityOperator","replacement":"idx >= elems.length","status":"Killed","description":"Killed by: odds combines identical sets"},{"id":"114","location":{"end":{"column":4,"line":62},"start":{"column":39,"line":60}},"mutatorName":"BlockStatement","replacement":"{}","status":"Killed","description":"Killed by: odds combines identical sets"},{"id":"115","location":{"end":{"column":67,"line":61},"start":{"column":12,"line":61}},"mutatorName":"ArrayDeclaration","replacement":"[]","status":"Killed","description":"Killed by: odds combines identical sets"},{"id":"116","location":{"end":{"column":65,"line":61},"start":{"column":58,"line":61}},"mutatorName":"ArithmeticOperator","replacement":"idx - 1","status":"Killed","description":"Killed by: odds combines identical sets"},{"id":"117","location":{"end":{"column":4,"line":64},"start":{"column":10,"line":62}},"mutatorName":"BlockStatement","replacement":"{}","status":"Killed","description":"Killed by: utils replace should return the same array if specified index is < 0"},{"id":"118","location":{"end":{"column":22,"line":63},"start":{"column":12,"line":63}},"mutatorName":"ArrayDeclaration","replacement":"[]","status":"Killed","description":"Killed by: utils replace should return the same array if specified index is < 0"},{"id":"94","location":{"end":{"column":36,"line":36},"start":{"column":33,"line":36}},"mutatorName":"UpdateOperator","replacement":"i--","status":"Timeout"}],"source":"/**\n * Flattens an array of arrays.\n *\n * @param T\n *   The type of the elements contained in the arrays.\n * @param {T[][]} elems\n *   An array of arrays.\n * @returns {T[]}\n *   A flattened array.\n */\nexport function flatten<T>(elems: T[][]): T[] {\n  return [].concat.apply([], elems);\n}\n\n/**\n * Compare 2 arrays using `===`. No deep comparaison.\n *\n * @param T\n *   The type of the elements contained in the arrays.\n * @param {T[]} a\n *   First array.\n * @param {T[]} b\n *   Second array.\n * @return {boolean}\n *   True if `a` and `b` contains the same values in the same order.\n */\nexport function arrayEquals<T>(a: T[], b: T[]): boolean {\n  if (!(Array.isArray(a) && Array.isArray(b))) {\n    return false;\n  }\n\n  if (a.length !== b.length) {\n    return false;\n  }\n\n  for (let i = 0; i < a.length; i++) {\n    if (a[i] !== b[i]) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\n/**\n * Returns a new array with element at index `idx` replaced with `elem`.\n *\n * @param T\n *   The type of the elements contained in the array.\n * @param {T[]} elems\n *   The original array.\n * @param {number} idx\n *   The index at which to replace.\n * @param {T} elem\n *   The element to place at the specified index.\n * @return {T[]}\n *   A new array with the element replaced.\n */\nexport function replace<T>(elems: T[], idx: number, elem: T): T[] {\n  if (idx >= 0 && idx < elems.length) {\n    return [...elems.slice(0, idx), elem, ...elems.slice(idx + 1)];\n  } else {\n    return [...elems];\n  }\n}\n"}},"schemaVersion":"1.0","thresholds":{"high":80,"low":60,"break":null}};